import {
  observeResize,
  watch,
  when
} from "./chunk-7QV74WTN.js";
import {
  $,
  DefinedController,
  HasSlotController,
  MduiElement,
  booleanConverter,
  componentStyle,
  isNodeName,
  property,
  queryAssignedElements,
  state
} from "./chunk-TEJKIG4D.js";
import {
  __decorate,
  css,
  customElement,
  html
} from "./chunk-TAWH3UXR.js";

// node_modules/mdui/components/layout/helper.js
var LayoutManager = class {
  constructor() {
    this.states = [];
  }
  /**
   * 注册 `<mdui-layout-main>`
   */
  registerMain(element) {
    this.$main = $(element);
  }
  /**
   * 取消注册 `<mdui-layout-main>`
   */
  unregisterMain() {
    this.$main = void 0;
  }
  /**
   * 注册新的 `<mdui-layout-item>`
   */
  registerItem(element) {
    const state2 = { element };
    this.states.push(state2);
    state2.observeResize = observeResize(state2.element, () => {
      this.updateLayout(state2.element, {
        width: this.isNoWidth(state2) ? 0 : void 0
      });
    });
    this.items = void 0;
    this.resort();
    this.updateLayout();
  }
  /**
   * 取消注册 `<mdui-layout-item>`
   */
  unregisterItem(element) {
    const index = this.states.findIndex((item2) => item2.element === element);
    if (index < 0) {
      return;
    }
    const item = this.states[index];
    item.observeResize?.unobserve();
    this.items = void 0;
    this.states.splice(index, 1);
    if (this.states[index]) {
      this.updateLayout(this.states[index].element);
    }
  }
  /**
   * 获取所有 `<mdui-layout-item>` 元素（按在 DOM 中的顺序）
   */
  getItems() {
    if (!this.items) {
      const items = this.states.map((state2) => state2.element);
      this.items = items.sort((a, b) => {
        const position = a.compareDocumentPosition(b);
        if (position & Node.DOCUMENT_POSITION_FOLLOWING) {
          return -1;
        } else if (position & Node.DOCUMENT_POSITION_PRECEDING) {
          return 1;
        } else {
          return 0;
        }
      });
    }
    return this.items;
  }
  /**
   * 获取 `<mdui-layout-main>` 元素
   */
  getMain() {
    return this.$main ? this.$main[0] : void 0;
  }
  /**
   * 获取 `<mdui-layout-item>` 及 `<mdui-layout-main>` 元素
   */
  getItemsAndMain() {
    return [...this.getItems(), this.getMain()].filter((i) => i);
  }
  /**
   * 更新 `order` 值，更新完后重新计算布局
   */
  updateOrder() {
    this.resort();
    this.updateLayout();
  }
  /**
   * 重新计算布局
   * @param element 从哪一个元素开始更新；若未传入参数，则将更新所有元素
   * @param size 此次更新中，元素的宽高（仅在此次更新中使用）。若不传则自动计算
   */
  updateLayout(element, size) {
    const state2 = element ? {
      element,
      width: size?.width,
      height: size?.height
    } : void 0;
    const index = state2 ? this.states.findIndex((v) => v.element === state2.element) : 0;
    if (index < 0) {
      return;
    }
    Object.assign(this.states[index], state2);
    this.states.forEach((currState, currIndex) => {
      if (currIndex < index) {
        return;
      }
      const placement = currState.element.layoutPlacement;
      const prevState = currIndex > 0 ? this.states[currIndex - 1] : void 0;
      const top = prevState?.top ?? 0;
      const right = prevState?.right ?? 0;
      const bottom = prevState?.bottom ?? 0;
      const left = prevState?.left ?? 0;
      Object.assign(currState, { top, right, bottom, left });
      switch (placement) {
        case "top":
        case "bottom":
          currState[placement] += currState.height ?? currState.element.offsetHeight;
          break;
        case "right":
        case "left":
          currState[placement] += (this.isNoWidth(currState) ? 0 : currState.width) ?? currState.element.offsetWidth;
          break;
      }
      currState.height = currState.width = void 0;
      $(currState.element).css({
        position: "absolute",
        top: placement === "bottom" ? null : top,
        right: placement === "left" ? null : right,
        bottom: placement === "top" ? null : bottom,
        left: placement === "right" ? null : left
      });
    });
    const lastState = this.states[this.states.length - 1];
    if (this.$main) {
      this.$main.css({
        paddingTop: lastState.top,
        paddingRight: lastState.right,
        paddingBottom: lastState.bottom,
        paddingLeft: lastState.left
      });
    }
  }
  /**
   * 按 order 排序，order 相同时，按在 DOM 中的顺序排序
   */
  resort() {
    const items = this.getItems();
    this.states.sort((a, b) => {
      const aOrder = a.element.order ?? 0;
      const bOrder = b.element.order ?? 0;
      if (aOrder > bOrder) {
        return 1;
      }
      if (aOrder < bOrder) {
        return -1;
      }
      if (items.indexOf(a.element) > items.indexOf(b.element)) {
        return 1;
      }
      if (items.indexOf(a.element) < items.indexOf(b.element)) {
        return -1;
      }
      return 0;
    });
  }
  /**
   * 组件宽度是否为 0
   * mdui-navigation-drawer 较为特殊，在为模态化时，占据的宽度为 0
   */
  isNoWidth(state2) {
    return isNodeName(state2.element, "mdui-navigation-drawer") && // @ts-ignore
    state2.element.isModal;
  }
};
var layoutManagerMap = /* @__PURE__ */ new WeakMap();
var getLayout = (element) => {
  if (!layoutManagerMap.has(element)) {
    layoutManagerMap.set(element, new LayoutManager());
  }
  return layoutManagerMap.get(element);
};

// node_modules/mdui/components/layout/layout-item-base.js
var LayoutItemBase = class extends MduiElement {
  constructor() {
    super(...arguments);
    this.isParentLayout = false;
  }
  /**
   * 当前布局组件所处的位置，父类必须实现该 getter
   */
  get layoutPlacement() {
    throw new Error("Must implement placement getter!");
  }
  // order 变更时，需要重新调整布局
  onOrderChange() {
    this.layoutManager?.updateOrder();
  }
  connectedCallback() {
    super.connectedCallback();
    const parentElement = this.parentElement;
    this.isParentLayout = isNodeName(parentElement, "mdui-layout");
    if (this.isParentLayout) {
      this.layoutManager = getLayout(parentElement);
      this.layoutManager.registerItem(this);
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this.layoutManager) {
      this.layoutManager.unregisterItem(this);
    }
  }
};
__decorate([
  property({ type: Number, reflect: true })
], LayoutItemBase.prototype, "order", void 0);
__decorate([
  watch("order", true)
], LayoutItemBase.prototype, "onOrderChange", null);

// node_modules/mdui/components/navigation-rail/navigation-rail-style.js
var navigationRailStyle = css`:host{--shape-corner:var(--mdui-shape-corner-none);--z-index:2000;position:fixed;top:0;bottom:0;left:0;display:flex;flex-direction:column;align-items:center;border-radius:0 var(--shape-corner) var(--shape-corner) 0;z-index:var(--z-index);width:5rem;background-color:rgb(var(--mdui-color-surface));padding:.375rem .75rem}:host([contained]:not([contained=false i])){position:absolute}:host([divider]:not([divider=false i])){border-right:.0625rem solid rgb(var(--mdui-color-surface-variant));width:5.0625rem}:host([placement=right]){left:initial;right:0;border-radius:var(--shape-corner) 0 0 var(--shape-corner)}:host([placement=right][divider]:not([divider=false i])){border-right:none;border-left:.0625rem solid rgb(var(--mdui-color-surface-variant))}.bottom,.items,.top{display:flex;flex-direction:column;align-items:center;width:100%}.top{margin-bottom:1.75rem}.bottom{margin-top:1.75rem}::slotted([slot=bottom]),::slotted([slot=top]),::slotted(mdui-navigation-rail-item){margin-top:.375rem;margin-bottom:.375rem}:host([alignment=start]) .top-spacer{flex-grow:0}:host([alignment=start]) .bottom-spacer{flex-grow:1}:host([alignment=end]) .top-spacer{flex-grow:1}:host([alignment=end]) .bottom-spacer{flex-grow:0}:host([alignment=center]){justify-content:center}:host([alignment=center]) .bottom,:host([alignment=center]) .top{position:absolute}:host([alignment=center]) .top{top:.375rem}:host([alignment=center]) .bottom{bottom:.375rem}`;

// node_modules/mdui/components/navigation-rail/navigation-rail.js
var NavigationRail = class NavigationRail2 extends LayoutItemBase {
  constructor() {
    super(...arguments);
    this.placement = "left";
    this.alignment = "start";
    this.contained = false;
    this.divider = false;
    this.activeKey = 0;
    this.hasSlotController = new HasSlotController(this, "top", "bottom");
    this.definedController = new DefinedController(this, {
      relatedElements: ["mdui-navigation-rail-item"]
    });
    this.isInitial = true;
  }
  get layoutPlacement() {
    return this.placement;
  }
  get parentTarget() {
    return this.contained || this.isParentLayout ? this.parentElement : document.body;
  }
  get isRight() {
    return this.placement === "right";
  }
  get paddingValue() {
    return ["fixed", "absolute"].includes($(this).css("position")) ? this.offsetWidth : void 0;
  }
  async onActiveKeyChange() {
    await this.definedController.whenDefined();
    const item = this.items.find((item2) => item2.key === this.activeKey);
    this.value = item?.value;
    if (!this.isInitial) {
      this.emit("change");
    }
  }
  async onValueChange() {
    this.isInitial = !this.hasUpdated;
    await this.definedController.whenDefined();
    const item = this.items.find((item2) => item2.value === this.value);
    this.activeKey = item?.key ?? 0;
    this.updateItems();
  }
  async onContainedChange() {
    if (this.isParentLayout) {
      return;
    }
    await this.definedController.whenDefined();
    $(document.body).css({
      paddingLeft: this.contained || this.isRight ? null : this.paddingValue,
      paddingRight: this.contained || !this.isRight ? null : this.paddingValue
    });
    $(this.parentElement).css({
      paddingLeft: this.contained && !this.isRight ? this.paddingValue : null,
      paddingRight: this.contained && this.isRight ? this.paddingValue : null
    });
  }
  async onPlacementChange() {
    await this.definedController.whenDefined();
    this.layoutManager?.updateLayout(this);
    this.items.forEach((item) => {
      item.placement = this.placement;
    });
    if (!this.isParentLayout) {
      $(this.parentTarget).css({
        paddingLeft: this.isRight ? null : this.paddingValue,
        paddingRight: this.isRight ? this.paddingValue : null
      });
    }
  }
  connectedCallback() {
    super.connectedCallback();
    if (!this.isParentLayout) {
      this.definedController.whenDefined().then(() => {
        $(this.parentTarget).css({
          paddingLeft: this.isRight ? null : this.paddingValue,
          paddingRight: this.isRight ? this.paddingValue : null
        });
      });
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    if (!this.isParentLayout && this.definedController.isDefined()) {
      $(this.parentTarget).css({
        paddingLeft: this.isRight ? void 0 : null,
        paddingRight: this.isRight ? null : void 0
      });
    }
  }
  render() {
    const hasTopSlot = this.hasSlotController.test("top");
    const hasBottomSlot = this.hasSlotController.test("bottom");
    return html`${when(hasTopSlot, () => html`<slot name="top" part="top" class="top"></slot>`)} <span class="top-spacer"></span><slot part="items" class="items" @slotchange="${this.onSlotChange}" @click="${this.onClick}"></slot><span class="bottom-spacer"></span> ${when(hasBottomSlot, () => html`<slot name="bottom" part="bottom" class="bottom"></slot>`)}`;
  }
  onClick(event) {
    if (event.button) {
      return;
    }
    const target = event.target;
    const item = target.closest("mdui-navigation-rail-item");
    if (!item) {
      return;
    }
    this.activeKey = item.key;
    this.isInitial = false;
    this.updateItems();
  }
  updateItems() {
    this.items.forEach((item) => {
      item.active = this.activeKey === item.key;
      item.placement = this.placement;
      item.isInitial = this.isInitial;
    });
  }
  async onSlotChange() {
    await this.definedController.whenDefined();
    this.updateItems();
  }
};
NavigationRail.styles = [
  componentStyle,
  navigationRailStyle
];
__decorate([
  property({ reflect: true })
], NavigationRail.prototype, "value", void 0);
__decorate([
  property({ reflect: true })
  // eslint-disable-next-line prettier/prettier
], NavigationRail.prototype, "placement", void 0);
__decorate([
  property({ reflect: true })
], NavigationRail.prototype, "alignment", void 0);
__decorate([
  property({
    type: Boolean,
    reflect: true,
    converter: booleanConverter
  })
], NavigationRail.prototype, "contained", void 0);
__decorate([
  property({
    type: Boolean,
    reflect: true,
    converter: booleanConverter
  })
], NavigationRail.prototype, "divider", void 0);
__decorate([
  state()
], NavigationRail.prototype, "activeKey", void 0);
__decorate([
  queryAssignedElements({
    selector: "mdui-navigation-rail-item",
    flatten: true
  })
], NavigationRail.prototype, "items", void 0);
__decorate([
  watch("activeKey", true)
], NavigationRail.prototype, "onActiveKeyChange", null);
__decorate([
  watch("value")
], NavigationRail.prototype, "onValueChange", null);
__decorate([
  watch("contained", true)
], NavigationRail.prototype, "onContainedChange", null);
__decorate([
  watch("placement", true)
], NavigationRail.prototype, "onPlacementChange", null);
NavigationRail = __decorate([
  customElement("mdui-navigation-rail")
], NavigationRail);

export {
  getLayout,
  LayoutItemBase,
  NavigationRail
};
//# sourceMappingURL=chunk-GMZ42CAL.js.map
