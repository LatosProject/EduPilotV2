import {
  $,
  DefinedController,
  HasSlotController,
  JQ,
  MduiElement,
  appendChild,
  booleanConverter,
  componentStyle,
  createElement,
  eachArray,
  eachObject,
  getAttribute,
  getDocument,
  getWindow,
  isArrayLike,
  isElement,
  isFunction,
  isObjectLike,
  isString,
  isUndefined,
  property,
  removeAttribute,
  removeChild,
  returnFalse,
  setAttribute,
  state,
  toCamelCase,
  toElement,
  unique
} from "./chunk-TEJKIG4D.js";
import {
  Directive,
  PartType,
  directive,
  unsafeSVG
} from "./chunk-R32BRYKZ.js";
import {
  _$LH,
  __decorate,
  css,
  customElement,
  html,
  noChange,
  nothing
} from "./chunk-TAWH3UXR.js";

// node_modules/lit-html/development/directives/style-map.js
var important = "important";
var importantFlag = " !" + important;
var flagTrim = 0 - importantFlag.length;
var StyleMapDirective = class extends Directive {
  constructor(partInfo) {
    super(partInfo);
    if (partInfo.type !== PartType.ATTRIBUTE || partInfo.name !== "style" || partInfo.strings?.length > 2) {
      throw new Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
    }
  }
  render(styleInfo) {
    return Object.keys(styleInfo).reduce((style3, prop) => {
      const value = styleInfo[prop];
      if (value == null) {
        return style3;
      }
      prop = prop.includes("-") ? prop : prop.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase();
      return style3 + `${prop}:${value};`;
    }, "");
  }
  update(part, [styleInfo]) {
    const { style: style3 } = part.element;
    if (this._previousStyleProperties === void 0) {
      this._previousStyleProperties = new Set(Object.keys(styleInfo));
      return this.render(styleInfo);
    }
    for (const name of this._previousStyleProperties) {
      if (styleInfo[name] == null) {
        this._previousStyleProperties.delete(name);
        if (name.includes("-")) {
          style3.removeProperty(name);
        } else {
          style3[name] = null;
        }
      }
    }
    for (const name in styleInfo) {
      const value = styleInfo[name];
      if (value != null) {
        this._previousStyleProperties.add(name);
        const isImportant = typeof value === "string" && value.endsWith(importantFlag);
        if (name.includes("-") || isImportant) {
          style3.setProperty(name, isImportant ? value.slice(0, flagTrim) : value, isImportant ? important : "");
        } else {
          style3[name] = value;
        }
      }
    }
    return noChange;
  }
};
var styleMap = directive(StyleMapDirective);

// node_modules/lit-html/development/directive-helpers.js
var { _ChildPart: ChildPart } = _$LH;
var ENABLE_SHADYDOM_NOPATCH = true;
var wrap = ENABLE_SHADYDOM_NOPATCH && window.ShadyDOM?.inUse && window.ShadyDOM?.noPatch === true ? window.ShadyDOM.wrap : (node) => node;
var isPrimitive = (value) => value === null || typeof value != "object" && typeof value != "function";
var isSingleExpression = (part) => part.strings === void 0;
var RESET_VALUE = {};
var setCommittedValue = (part, value = RESET_VALUE) => part._$committedValue = value;

// node_modules/lit-html/development/async-directive.js
var DEV_MODE = true;
var notifyChildrenConnectedChanged = (parent, isConnected) => {
  const children = parent._$disconnectableChildren;
  if (children === void 0) {
    return false;
  }
  for (const obj of children) {
    obj["_$notifyDirectiveConnectionChanged"]?.(isConnected, false);
    notifyChildrenConnectedChanged(obj, isConnected);
  }
  return true;
};
var removeDisconnectableFromParent = (obj) => {
  let parent, children;
  do {
    if ((parent = obj._$parent) === void 0) {
      break;
    }
    children = parent._$disconnectableChildren;
    children.delete(obj);
    obj = parent;
  } while (children?.size === 0);
};
var addDisconnectableToParent = (obj) => {
  for (let parent; parent = obj._$parent; obj = parent) {
    let children = parent._$disconnectableChildren;
    if (children === void 0) {
      parent._$disconnectableChildren = children = /* @__PURE__ */ new Set();
    } else if (children.has(obj)) {
      break;
    }
    children.add(obj);
    installDisconnectAPI(parent);
  }
};
function reparentDisconnectables(newParent) {
  if (this._$disconnectableChildren !== void 0) {
    removeDisconnectableFromParent(this);
    this._$parent = newParent;
    addDisconnectableToParent(this);
  } else {
    this._$parent = newParent;
  }
}
function notifyChildPartConnectedChanged(isConnected, isClearingValue = false, fromPartIndex = 0) {
  const value = this._$committedValue;
  const children = this._$disconnectableChildren;
  if (children === void 0 || children.size === 0) {
    return;
  }
  if (isClearingValue) {
    if (Array.isArray(value)) {
      for (let i = fromPartIndex; i < value.length; i++) {
        notifyChildrenConnectedChanged(value[i], false);
        removeDisconnectableFromParent(value[i]);
      }
    } else if (value != null) {
      notifyChildrenConnectedChanged(value, false);
      removeDisconnectableFromParent(value);
    }
  } else {
    notifyChildrenConnectedChanged(this, isConnected);
  }
}
var installDisconnectAPI = (obj) => {
  if (obj.type == PartType.CHILD) {
    obj._$notifyConnectionChanged ??= notifyChildPartConnectedChanged;
    obj._$reparentDisconnectables ??= reparentDisconnectables;
  }
};
var AsyncDirective = class extends Directive {
  constructor() {
    super(...arguments);
    this._$disconnectableChildren = void 0;
  }
  /**
   * Initialize the part with internal fields
   * @param part
   * @param parent
   * @param attributeIndex
   */
  _$initialize(part, parent, attributeIndex) {
    super._$initialize(part, parent, attributeIndex);
    addDisconnectableToParent(this);
    this.isConnected = part._$isConnected;
  }
  // This property needs to remain unminified.
  /**
   * Called from the core code when a directive is going away from a part (in
   * which case `shouldRemoveFromParent` should be true), and from the
   * `setChildrenConnected` helper function when recursively changing the
   * connection state of a tree (in which case `shouldRemoveFromParent` should
   * be false).
   *
   * @param isConnected
   * @param isClearingDirective - True when the directive itself is being
   *     removed; false when the tree is being disconnected
   * @internal
   */
  ["_$notifyDirectiveConnectionChanged"](isConnected, isClearingDirective = true) {
    if (isConnected !== this.isConnected) {
      this.isConnected = isConnected;
      if (isConnected) {
        this.reconnected?.();
      } else {
        this.disconnected?.();
      }
    }
    if (isClearingDirective) {
      notifyChildrenConnectedChanged(this, isConnected);
      removeDisconnectableFromParent(this);
    }
  }
  /**
   * Sets the value of the directive's Part outside the normal `update`/`render`
   * lifecycle of a directive.
   *
   * This method should not be called synchronously from a directive's `update`
   * or `render`.
   *
   * @param directive The directive to update
   * @param value The value to set
   */
  setValue(value) {
    if (isSingleExpression(this.__part)) {
      this.__part._$setValue(value, this);
    } else {
      if (DEV_MODE && this.__attributeIndex === void 0) {
        throw new Error(`Expected this.__attributeIndex to be a number`);
      }
      const newValues = [...this.__part._$committedValue];
      newValues[this.__attributeIndex] = value;
      this.__part._$setValue(newValues, this, 0);
    }
  }
  /**
   * User callbacks for implementing logic to release any resources/subscriptions
   * that may have been retained by this directive. Since directives may also be
   * re-connected, `reconnected` should also be implemented to restore the
   * working state of the directive prior to the next render.
   */
  disconnected() {
  }
  reconnected() {
  }
};

// node_modules/lit-html/development/directives/private-async-helpers.js
var PseudoWeakRef = class {
  constructor(ref2) {
    this._ref = ref2;
  }
  /**
   * Disassociates the ref with the backing instance.
   */
  disconnect() {
    this._ref = void 0;
  }
  /**
   * Reassociates the ref with the backing instance.
   */
  reconnect(ref2) {
    this._ref = ref2;
  }
  /**
   * Retrieves the backing instance (will be undefined when disconnected)
   */
  deref() {
    return this._ref;
  }
};
var Pauser = class {
  constructor() {
    this._promise = void 0;
    this._resolve = void 0;
  }
  /**
   * When paused, returns a promise to be awaited; when unpaused, returns
   * undefined. Note that in the microtask between the pauser being resumed
   * an await of this promise resolving, the pauser could be paused again,
   * hence callers should check the promise in a loop when awaiting.
   * @returns A promise to be awaited when paused or undefined
   */
  get() {
    return this._promise;
  }
  /**
   * Creates a promise to be awaited
   */
  pause() {
    this._promise ??= new Promise((resolve) => this._resolve = resolve);
  }
  /**
   * Resolves the promise which may be awaited
   */
  resume() {
    this._resolve?.();
    this._promise = this._resolve = void 0;
  }
};

// node_modules/lit-html/development/directives/until.js
var isPromise = (x) => {
  return !isPrimitive(x) && typeof x.then === "function";
};
var _infinity = 1073741823;
var UntilDirective = class extends AsyncDirective {
  constructor() {
    super(...arguments);
    this.__lastRenderedIndex = _infinity;
    this.__values = [];
    this.__weakThis = new PseudoWeakRef(this);
    this.__pauser = new Pauser();
  }
  render(...args) {
    return args.find((x) => !isPromise(x)) ?? noChange;
  }
  update(_part, args) {
    const previousValues = this.__values;
    let previousLength = previousValues.length;
    this.__values = args;
    const weakThis = this.__weakThis;
    const pauser = this.__pauser;
    if (!this.isConnected) {
      this.disconnected();
    }
    for (let i = 0; i < args.length; i++) {
      if (i > this.__lastRenderedIndex) {
        break;
      }
      const value = args[i];
      if (!isPromise(value)) {
        this.__lastRenderedIndex = i;
        return value;
      }
      if (i < previousLength && value === previousValues[i]) {
        continue;
      }
      this.__lastRenderedIndex = _infinity;
      previousLength = 0;
      Promise.resolve(value).then(async (result) => {
        while (pauser.get()) {
          await pauser.get();
        }
        const _this = weakThis.deref();
        if (_this !== void 0) {
          const index = _this.__values.indexOf(value);
          if (index > -1 && index < _this.__lastRenderedIndex) {
            _this.__lastRenderedIndex = index;
            _this.setValue(result);
          }
        }
      });
    }
    return noChange;
  }
  disconnected() {
    this.__weakThis.disconnect();
    this.__pauser.pause();
  }
  reconnected() {
    this.__weakThis.reconnect(this);
    this.__pauser.resume();
  }
};
var until = directive(UntilDirective);

// node_modules/@mdui/jq/functions/contains.js
var contains = (container, contains2) => {
  return container !== contains2 && toElement(container).contains(contains2);
};

// node_modules/@mdui/jq/functions/merge.js
var merge = (first, second) => {
  eachArray(second, (value) => {
    first.push(value);
  });
  return first;
};

// node_modules/@mdui/jq/methods/find.js
$.fn.find = function(selector) {
  const foundElements = [];
  this.each((_, element) => {
    merge(foundElements, $(element.querySelectorAll(selector)).get());
  });
  return new JQ(foundElements);
};

// node_modules/@mdui/jq/shared/event.js
var CustomEvent = getWindow().CustomEvent;
var MduiCustomEvent = class extends CustomEvent {
  constructor(type, options) {
    super(type, options);
    this.data = options.data;
    this.namespace = options.namespace;
  }
};
var elementIdMap = /* @__PURE__ */ new WeakMap();
var elementId = 1;
var getElementId = (element) => {
  if (!elementIdMap.has(element)) {
    elementIdMap.set(element, ++elementId);
  }
  return elementIdMap.get(element);
};
var handlersMap = /* @__PURE__ */ new Map();
var getHandlers = (element) => {
  const id = getElementId(element);
  return handlersMap.get(id) || handlersMap.set(id, []).get(id);
};
var parse = (type) => {
  const parts = type.split(".");
  return {
    type: parts[0],
    namespace: parts.slice(1).sort().join(" ")
  };
};
var matcherFor = (namespace) => {
  return new RegExp("(?:^| )" + namespace.replace(" ", " .* ?") + "(?: |$)");
};
var getMatchedHandlers = (element, type, func, selector) => {
  const event = parse(type);
  return getHandlers(element).filter((handler) => {
    return handler && (!event.type || handler.type === event.type) && (!event.namespace || matcherFor(event.namespace).test(handler.namespace)) && (!func || getElementId(handler.func) === getElementId(func)) && (!selector || handler.selector === selector);
  });
};
var add = (element, types, func, data, selector) => {
  let useCapture = false;
  if (isObjectLike(data) && data.useCapture) {
    useCapture = true;
  }
  types.split(" ").forEach((type) => {
    if (!type) {
      return;
    }
    const event = parse(type);
    const callFn = (e, elem) => {
      const result = func.apply(
        elem,
        // @ts-ignore
        e.detail === null ? [e] : [e].concat(e.detail)
      );
      if (result === false) {
        e.preventDefault();
        e.stopPropagation();
      }
    };
    const proxyFn = (e) => {
      if (e.namespace && !matcherFor(e.namespace).test(event.namespace)) {
        return;
      }
      e.data = data;
      if (selector) {
        $(element).find(selector).get().reverse().forEach((elem) => {
          if (elem === e.target || contains(elem, e.target)) {
            callFn(e, elem);
          }
        });
      } else {
        callFn(e, element);
      }
    };
    const handler = {
      type: event.type,
      namespace: event.namespace,
      func,
      selector,
      id: getHandlers(element).length,
      proxy: proxyFn
    };
    getHandlers(element).push(handler);
    element.addEventListener(handler.type, proxyFn, useCapture);
  });
};
var remove = (element, types, func, selector) => {
  const handlersInElement = getHandlers(element);
  const removeEvent = (handler) => {
    delete handlersInElement[handler.id];
    element.removeEventListener(handler.type, handler.proxy, false);
  };
  if (!types) {
    handlersInElement.forEach((handler) => {
      removeEvent(handler);
    });
  } else {
    types.split(" ").forEach((type) => {
      if (type) {
        getMatchedHandlers(element, type, func, selector).forEach((handler) => {
          removeEvent(handler);
        });
      }
    });
  }
};

// node_modules/@mdui/jq/methods/trigger.js
$.fn.trigger = function(name, detail = null, options) {
  const { type, namespace } = parse(name);
  const event = new MduiCustomEvent(type, {
    detail,
    data: null,
    namespace,
    bubbles: true,
    cancelable: false,
    composed: true,
    ...options
  });
  return this.each((_, element) => {
    element.dispatchEvent(event);
  });
};

// node_modules/@mdui/jq/functions/extend.js
function extend(target, ...objectN) {
  eachArray(objectN, (object) => {
    eachObject(object, (prop, value) => {
      if (!isUndefined(value)) {
        target[prop] = value;
      }
    });
  });
  return target;
}

// node_modules/@mdui/jq/shared/ajax.js
var ajaxStart = "ajaxStart";
var ajaxSuccess = "ajaxSuccess";
var ajaxError = "ajaxError";
var ajaxComplete = "ajaxComplete";
var globalOptions = {};
var isQueryStringData = (method) => {
  return ["GET", "HEAD"].includes(method);
};
var appendQuery = (url, query) => {
  return `${url}&${query}`.replace(/[&?]{1,2}/, "?");
};
var isCrossDomain = (url) => {
  const window2 = getWindow();
  return /^([\w-]+:)?\/\/([^/]+)/.test(url) && RegExp.$2 !== window2.location.host;
};
var isHttpStatusSuccess = (status) => {
  return status >= 200 && status < 300 || [0, 304].includes(status);
};
var mergeOptions = (options) => {
  const defaults = {
    url: "",
    method: "GET",
    data: "",
    processData: true,
    async: true,
    cache: true,
    username: "",
    password: "",
    headers: {},
    xhrFields: {},
    statusCode: {},
    dataType: "",
    contentType: "application/x-www-form-urlencoded",
    timeout: 0,
    global: true
  };
  eachObject(globalOptions, (key, value) => {
    const callbacks = [
      "beforeSend",
      "success",
      "error",
      "complete",
      "statusCode"
    ];
    if (!callbacks.includes(key) && !isUndefined(value)) {
      defaults[key] = value;
    }
  });
  return extend({}, defaults, options);
};

// node_modules/@mdui/jq/functions/param.js
var param = (obj) => {
  if (!isObjectLike(obj) && !Array.isArray(obj)) {
    return "";
  }
  const args = [];
  const destructure = (key, value) => {
    let keyTmp;
    if (isObjectLike(value)) {
      eachObject(value, (i, v) => {
        keyTmp = Array.isArray(value) && !isObjectLike(v) ? "" : i;
        destructure(`${key}[${keyTmp}]`, v);
      });
    } else {
      keyTmp = value == null || value === "" ? "=" : `=${encodeURIComponent(value)}`;
      args.push(encodeURIComponent(key) + keyTmp);
    }
  };
  if (Array.isArray(obj)) {
    eachArray(obj, ({ name, value }) => {
      return destructure(name, value);
    });
  } else {
    eachObject(obj, destructure);
  }
  return args.join("&");
};

// node_modules/@mdui/jq/functions/ajax.js
var ajax = (options) => {
  const document3 = getDocument();
  const window2 = getWindow();
  let isCanceled = false;
  const eventParams = {};
  const successEventParams = {};
  const mergedOptions = mergeOptions(options);
  const method = mergedOptions.method.toUpperCase();
  let { data, url } = mergedOptions;
  url = url || window2.location.toString();
  const { processData, async, cache, username, password, headers, xhrFields, statusCode, dataType, contentType, timeout, global } = mergedOptions;
  const isMethodQueryString = isQueryStringData(method);
  if (data && (isMethodQueryString || processData) && !isString(data) && !(data instanceof ArrayBuffer) && !(data instanceof Blob) && !(data instanceof Document) && !(data instanceof FormData)) {
    data = param(data);
  }
  if (data && isMethodQueryString) {
    url = appendQuery(url, data);
    data = null;
  }
  const trigger = (event, callback, ...args) => {
    if (global) {
      $(document3).trigger(event, callback === "success" ? successEventParams : eventParams);
    }
    let resultGlobal;
    let resultCustom;
    if (callback in globalOptions) {
      resultGlobal = globalOptions[callback](...args);
    }
    if (mergedOptions[callback]) {
      resultCustom = mergedOptions[callback](...args);
    }
    if (callback === "beforeSend" && [resultGlobal, resultCustom].includes(false)) {
      isCanceled = true;
    }
  };
  const XHR = () => {
    let textStatus;
    return new Promise((resolve, reject) => {
      const doReject = (reason) => {
        return reject(new Error(reason));
      };
      if (isMethodQueryString && !cache) {
        url = appendQuery(url, `_=${Date.now()}`);
      }
      const xhr = new XMLHttpRequest();
      xhr.open(method, url, async, username, password);
      if (contentType || data && !isMethodQueryString && contentType !== false) {
        xhr.setRequestHeader("Content-Type", contentType);
      }
      if (dataType === "json") {
        xhr.setRequestHeader("Accept", "application/json, text/javascript");
      }
      eachObject(headers, (key, value) => {
        if (!isUndefined(value)) {
          xhr.setRequestHeader(key, value + "");
        }
      });
      if (!isCrossDomain(url)) {
        xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
      }
      eachObject(xhrFields, (key, value) => {
        xhr[key] = value;
      });
      eventParams.xhr = successEventParams.xhr = xhr;
      eventParams.options = successEventParams.options = mergedOptions;
      let xhrTimeout;
      xhr.onload = () => {
        if (xhrTimeout) {
          clearTimeout(xhrTimeout);
        }
        const isSuccess = isHttpStatusSuccess(xhr.status);
        let responseData = void 0;
        if (isSuccess) {
          textStatus = xhr.status === 204 || method === "HEAD" ? "nocontent" : xhr.status === 304 ? "notmodified" : "success";
          if (dataType === "json" || !dataType && (xhr.getResponseHeader("content-type") || "").includes("json")) {
            try {
              responseData = method === "HEAD" ? void 0 : JSON.parse(xhr.responseText);
              successEventParams.response = responseData;
            } catch (_err) {
              textStatus = "parsererror";
              trigger(ajaxError, "error", xhr, textStatus);
              doReject(textStatus);
            }
            if (textStatus !== "parsererror") {
              trigger(ajaxSuccess, "success", responseData, textStatus, xhr);
              resolve(responseData);
            }
          } else {
            responseData = method === "HEAD" ? void 0 : xhr.responseType === "text" || xhr.responseType === "" ? xhr.responseText : xhr.response;
            successEventParams.response = responseData;
            trigger(ajaxSuccess, "success", responseData, textStatus, xhr);
            resolve(responseData);
          }
        } else {
          textStatus = "error";
          trigger(ajaxError, "error", xhr, textStatus);
          doReject(textStatus);
        }
        eachArray([globalOptions.statusCode ?? {}, statusCode], (func) => {
          if (func[xhr.status]) {
            if (isSuccess) {
              func[xhr.status](responseData, textStatus, xhr);
            } else {
              func[xhr.status](xhr, textStatus);
            }
          }
        });
        trigger(ajaxComplete, "complete", xhr, textStatus);
      };
      xhr.onerror = () => {
        if (xhrTimeout) {
          clearTimeout(xhrTimeout);
        }
        trigger(ajaxError, "error", xhr, xhr.statusText);
        trigger(ajaxComplete, "complete", xhr, "error");
        doReject(xhr.statusText);
      };
      xhr.onabort = () => {
        let statusText = "abort";
        if (xhrTimeout) {
          statusText = "timeout";
          clearTimeout(xhrTimeout);
        }
        trigger(ajaxError, "error", xhr, statusText);
        trigger(ajaxComplete, "complete", xhr, statusText);
        doReject(statusText);
      };
      trigger(ajaxStart, "beforeSend", xhr, mergedOptions);
      if (isCanceled) {
        return doReject("cancel");
      }
      if (timeout > 0) {
        xhrTimeout = window2.setTimeout(() => xhr.abort(), timeout);
      }
      xhr.send(data);
    });
  };
  return XHR();
};

// node_modules/mdui/components/icon/style.js
var style = css`:host{display:inline-block;width:1em;height:1em;font-weight:400;font-family:'Material Icons';font-display:block;font-style:normal;line-height:1;direction:ltr;letter-spacing:normal;white-space:nowrap;text-transform:none;word-wrap:normal;-webkit-font-smoothing:antialiased;text-rendering:optimizelegibility;-moz-osx-font-smoothing:grayscale;font-size:1.5rem}::slotted(svg),svg{width:100%;height:100%;fill:currentcolor}`;

// node_modules/mdui/components/icon/index.js
var Icon = class Icon2 extends MduiElement {
  constructor() {
    super(...arguments);
    this.hasSlotController = new HasSlotController(this, "[default]");
  }
  render() {
    const renderDefault = () => {
      if (this.name) {
        const [name, variant] = this.name.split("--");
        const familyMap = /* @__PURE__ */ new Map([
          ["outlined", "Material Icons Outlined"],
          ["filled", "Material Icons"],
          ["rounded", "Material Icons Round"],
          ["sharp", "Material Icons Sharp"],
          ["two-tone", "Material Icons Two Tone"]
        ]);
        return html`<span translate="no" style="${styleMap({ fontFamily: familyMap.get(variant) })}">${name}</span>`;
      }
      if (this.src) {
        return html`${until(ajax({ url: this.src }).then(unsafeSVG))}`;
      }
      return html``;
    };
    return this.hasSlotController.test("[default]") ? html`<slot></slot>` : renderDefault();
  }
};
Icon.styles = [componentStyle, style];
__decorate([
  property({ reflect: true })
], Icon.prototype, "name", void 0);
__decorate([
  property({ reflect: true })
], Icon.prototype, "src", void 0);
Icon = __decorate([
  customElement("mdui-icon")
], Icon);

// node_modules/@mdui/jq/methods/off.js
$.fn.off = function(types, selector, callback) {
  if (isObjectLike(types)) {
    eachObject(types, (type, fn) => {
      this.off(type, selector, fn);
    });
    return this;
  }
  if (selector === false || isFunction(selector)) {
    callback = selector;
    selector = void 0;
  }
  if (callback === false) {
    callback = returnFalse;
  }
  return this.each(function() {
    remove(this, types, callback, selector);
  });
};

// node_modules/@mdui/jq/methods/on.js
$.fn.on = function(types, selector, data, callback, one) {
  if (isObjectLike(types)) {
    if (!isString(selector)) {
      data = data || selector;
      selector = void 0;
    }
    eachObject(types, (type, fn) => {
      this.on(type, selector, data, fn, one);
    });
    return this;
  }
  if (data == null && callback == null) {
    callback = selector;
    data = selector = void 0;
  } else if (callback == null) {
    if (isString(selector)) {
      callback = data;
      data = void 0;
    } else {
      callback = data;
      data = selector;
      selector = void 0;
    }
  }
  if (callback === false) {
    callback = returnFalse;
  } else if (!callback) {
    return this;
  }
  if (one) {
    const _this = this;
    const origCallback = callback;
    callback = function(event, ...dataN) {
      _this.off(event.type, selector, callback);
      return origCallback.call(this, event, ...dataN);
    };
  }
  return this.each(function() {
    add(this, types, callback, data, selector);
  });
};

// node_modules/@mdui/jq/methods/remove.js
$.fn.remove = function(selector) {
  return this.each((_, element) => {
    if (!selector || $(element).is(selector)) {
      removeChild(element);
    }
  });
};

// node_modules/@mdui/jq/methods/insertBefore.js
eachArray(["insertBefore", "insertAfter"], (name, nameIndex) => {
  $.fn[name] = function(target) {
    const $element = nameIndex ? $(this.get().reverse()) : this;
    const $target = $(target);
    const result = [];
    $target.each((index, target2) => {
      if (!target2.parentNode) {
        return;
      }
      $element.each((_, element) => {
        const newItem = index ? element.cloneNode(true) : element;
        const existingItem = nameIndex ? target2.nextSibling : target2;
        result.push(newItem);
        target2.parentNode.insertBefore(newItem, existingItem);
      });
    });
    return $(nameIndex ? result.reverse() : result);
  };
});

// node_modules/@mdui/jq/functions/each.js
function each(target, callback) {
  return isArrayLike(target) ? eachArray(target, (value, index) => {
    return callback.call(value, index, value);
  }) : eachObject(target, callback);
}

// node_modules/@mdui/jq/functions/map.js
function map(elements, callback) {
  const window2 = getWindow();
  let value;
  const ret = [];
  each(elements, (i, element) => {
    value = callback.call(window2, element, i);
    if (value != null) {
      ret.push(value);
    }
  });
  return [].concat(...ret);
}

// node_modules/@mdui/jq/methods/map.js
$.fn.map = function(callback) {
  return new JQ(map(this, (element, i) => {
    return callback.call(element, i, element);
  }));
};

// node_modules/@mdui/jq/methods/appendTo.js
eachArray(["appendTo", "prependTo"], (name, nameIndex) => {
  $.fn[name] = function(target) {
    const extraChilds = [];
    const $target = $(target).map((_, element) => {
      const childNodes = element.childNodes;
      const childLength = childNodes.length;
      if (childLength) {
        return childNodes[nameIndex ? 0 : childLength - 1];
      }
      const child = createElement("div");
      appendChild(element, child);
      extraChilds.push(child);
      return child;
    });
    const $result = this[nameIndex ? "insertBefore" : "insertAfter"]($target);
    $(extraChilds).remove();
    return $result;
  };
});

// node_modules/lit-html/development/directives/class-map.js
var ClassMapDirective = class extends Directive {
  constructor(partInfo) {
    super(partInfo);
    if (partInfo.type !== PartType.ATTRIBUTE || partInfo.name !== "class" || partInfo.strings?.length > 2) {
      throw new Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
    }
  }
  render(classInfo) {
    return " " + Object.keys(classInfo).filter((key) => classInfo[key]).join(" ") + " ";
  }
  update(part, [classInfo]) {
    if (this._previousClasses === void 0) {
      this._previousClasses = /* @__PURE__ */ new Set();
      if (part.strings !== void 0) {
        this._staticClasses = new Set(part.strings.join(" ").split(/\s/).filter((s) => s !== ""));
      }
      for (const name in classInfo) {
        if (classInfo[name] && !this._staticClasses?.has(name)) {
          this._previousClasses.add(name);
        }
      }
      return this.render(classInfo);
    }
    const classList = part.element.classList;
    for (const name of this._previousClasses) {
      if (!(name in classInfo)) {
        classList.remove(name);
        this._previousClasses.delete(name);
      }
    }
    for (const name in classInfo) {
      const value = !!classInfo[name];
      if (value !== this._previousClasses.has(name) && !this._staticClasses?.has(name)) {
        if (value) {
          classList.add(name);
          this._previousClasses.add(name);
        } else {
          classList.remove(name);
          this._previousClasses.delete(name);
        }
      }
    }
    return noChange;
  }
};
var classMap = directive(ClassMapDirective);

// node_modules/lit-html/development/directives/ref.js
var createRef = () => new Ref();
var Ref = class {
};
var lastElementForContextAndCallback = /* @__PURE__ */ new WeakMap();
var RefDirective = class extends AsyncDirective {
  render(_ref) {
    return nothing;
  }
  update(part, [ref2]) {
    const refChanged = ref2 !== this._ref;
    if (refChanged && this._ref !== void 0) {
      this._updateRefValue(void 0);
    }
    if (refChanged || this._lastElementForRef !== this._element) {
      this._ref = ref2;
      this._context = part.options?.host;
      this._updateRefValue(this._element = part.element);
    }
    return nothing;
  }
  _updateRefValue(element) {
    if (!this.isConnected) {
      element = void 0;
    }
    if (typeof this._ref === "function") {
      const context = this._context ?? globalThis;
      let lastElementForCallback = lastElementForContextAndCallback.get(context);
      if (lastElementForCallback === void 0) {
        lastElementForCallback = /* @__PURE__ */ new WeakMap();
        lastElementForContextAndCallback.set(context, lastElementForCallback);
      }
      if (lastElementForCallback.get(this._ref) !== void 0) {
        this._ref.call(this._context, void 0);
      }
      lastElementForCallback.set(this._ref, element);
      if (element !== void 0) {
        this._ref.call(this._context, element);
      }
    } else {
      this._ref.value = element;
    }
  }
  get _lastElementForRef() {
    return typeof this._ref === "function" ? lastElementForContextAndCallback.get(this._context ?? globalThis)?.get(this._ref) : this._ref?.value;
  }
  disconnected() {
    if (this._lastElementForRef === this._element) {
      this._updateRefValue(void 0);
    }
  }
  reconnected() {
    this._updateRefValue(this._element);
  }
};
var ref = directive(RefDirective);

// node_modules/@mdui/jq/methods/addClass.js
eachArray(["add", "remove", "toggle"], (name) => {
  $.fn[`${name}Class`] = function(className) {
    if (name === "remove" && !arguments.length) {
      return this.each((_, element) => {
        setAttribute(element, "class", "");
      });
    }
    return this.each((i, element) => {
      if (!isElement(element)) {
        return;
      }
      const classes = (isFunction(className) ? className.call(element, i, getAttribute(element, "class", "")) : className).split(" ").filter((name2) => name2);
      eachArray(classes, (cls) => {
        element.classList[name](cls);
      });
    });
  };
});

// node_modules/@mdui/jq/shared/data.js
var weakMap = /* @__PURE__ */ new WeakMap();
var getAll = (element) => {
  return weakMap.get(element) ?? {};
};
var get = (element, keyOriginal) => {
  const data = getAll(element);
  const key = toCamelCase(keyOriginal);
  return key in data ? data[key] : void 0;
};
var setAll = (element, object) => {
  const data = getAll(element);
  eachObject(object, (keyOriginal, value) => {
    data[toCamelCase(keyOriginal)] = value;
  });
  weakMap.set(element, data);
};
var set = (element, keyOriginal, value) => {
  setAll(element, { [keyOriginal]: value });
};
var removeAll = (element) => {
  weakMap.delete(element);
};
var removeMultiple = (element, keysOriginal) => {
  const data = getAll(element);
  eachArray(keysOriginal, (keyOriginal) => {
    const key = toCamelCase(keyOriginal);
    delete data[key];
  });
  weakMap.set(element, data);
};
var rbrace = /^(?:{[\w\W]*\}|\[[\w\W]*\])$/;
var stringTransform = (value) => {
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  if (value === "null") {
    return null;
  }
  if (value === +value + "") {
    return +value;
  }
  if (rbrace.test(value)) {
    return JSON.parse(value);
  }
  return value;
};
var dataAttr = (element, key, value) => {
  if (isUndefined(value) && element.nodeType === 1) {
    value = element.dataset[key];
    if (isString(value)) {
      try {
        value = stringTransform(value);
      } catch (_err) {
      }
    }
  }
  return value;
};

// node_modules/@mdui/jq/methods/data.js
$.fn.data = function(key, value) {
  if (isUndefined(key)) {
    if (!this.length) {
      return void 0;
    }
    const element = this[0];
    const resultData = getAll(element);
    if (element.nodeType !== 1) {
      return resultData;
    }
    eachObject(element.dataset, (key2) => {
      resultData[key2] = dataAttr(element, key2, resultData[key2]);
    });
    return resultData;
  }
  if (isObjectLike(key)) {
    return this.each(function() {
      setAll(this, key);
    });
  }
  if (arguments.length === 2 && isUndefined(value)) {
    return this;
  }
  if (!isUndefined(value)) {
    return this.each(function() {
      set(this, key, value);
    });
  }
  if (!this.length) {
    return void 0;
  }
  return dataAttr(this[0], toCamelCase(key), get(this[0], key));
};

// node_modules/@mdui/jq/methods/filter.js
$.fn.filter = function(selector) {
  if (isFunction(selector)) {
    return this.map((index, element) => {
      return selector.call(element, index, element) ? element : void 0;
    });
  }
  if (isString(selector)) {
    return this.map((_, element) => {
      return $(element).is(selector) ? element : void 0;
    });
  }
  const $selector = $(selector);
  return this.map((_, element) => {
    return $selector.get().includes(element) ? element : void 0;
  });
};

// node_modules/@mdui/jq/methods/slice.js
$.fn.slice = function(...args) {
  return new JQ([].slice.apply(this, args));
};

// node_modules/@mdui/jq/methods/eq.js
$.fn.eq = function(index) {
  const ret = index === -1 ? this.slice(index) : this.slice(index, +index + 1);
  return new JQ(ret);
};

// node_modules/@mdui/jq/methods/offsetParent.js
$.fn.offsetParent = function() {
  const document3 = getDocument();
  return this.map(function() {
    let offsetParent = this.offsetParent;
    while (offsetParent && $(offsetParent).css("position") === "static") {
      offsetParent = offsetParent.offsetParent;
    }
    return offsetParent || document3.documentElement;
  });
};

// node_modules/@mdui/jq/methods/position.js
var floatStyle = ($element, name) => {
  return parseFloat($element.css(name));
};
$.fn.position = function() {
  if (!this.length) {
    return void 0;
  }
  const $element = this.eq(0);
  let currentOffset;
  let parentOffset = {
    left: 0,
    top: 0
  };
  if ($element.css("position") === "fixed") {
    currentOffset = $element[0].getBoundingClientRect();
  } else {
    currentOffset = $element.offset();
    const $offsetParent = $element.offsetParent();
    parentOffset = $offsetParent.offset();
    parentOffset.top += floatStyle($offsetParent, "border-top-width");
    parentOffset.left += floatStyle($offsetParent, "border-left-width");
  }
  return {
    top: currentOffset.top - parentOffset.top - floatStyle($element, "margin-top"),
    left: currentOffset.left - parentOffset.left - floatStyle($element, "margin-left")
  };
};

// node_modules/@mdui/jq/methods/offset.js
var get2 = (element) => {
  if (!element.getClientRects().length) {
    return { top: 0, left: 0 };
  }
  const { top, left } = element.getBoundingClientRect();
  const { pageYOffset, pageXOffset } = element.ownerDocument.defaultView;
  return {
    top: top + pageYOffset,
    left: left + pageXOffset
  };
};
var set2 = (element, value, index) => {
  const $element = $(element);
  const position = $element.css("position");
  if (position === "static") {
    $element.css("position", "relative");
  }
  const currentOffset = get2(element);
  const currentTopString = $element.css("top");
  const currentLeftString = $element.css("left");
  let currentTop;
  let currentLeft;
  const calculatePosition = (position === "absolute" || position === "fixed") && (currentTopString + currentLeftString).includes("auto");
  if (calculatePosition) {
    const currentPosition = $element.position();
    currentTop = currentPosition.top;
    currentLeft = currentPosition.left;
  } else {
    currentTop = parseFloat(currentTopString);
    currentLeft = parseFloat(currentLeftString);
  }
  const computedValue = isFunction(value) ? value.call(element, index, extend({}, currentOffset)) : value;
  $element.css({
    top: computedValue.top != null ? computedValue.top - currentOffset.top + currentTop : void 0,
    left: computedValue.left != null ? computedValue.left - currentOffset.left + currentLeft : void 0
  });
};
$.fn.offset = function(value) {
  if (!arguments.length) {
    if (!this.length) {
      return void 0;
    }
    return get2(this[0]);
  }
  return this.each(function(index) {
    set2(this, value, index);
  });
};

// node_modules/mdui/components/ripple/style.js
var style2 = css`:host{position:absolute;top:0;left:0;display:block;width:100%;height:100%;overflow:hidden;pointer-events:none}.surface{position:absolute;top:0;left:0;width:100%;height:100%;transition-duration:280ms;transition-property:background-color;pointer-events:none;transition-timing-function:var(--mdui-motion-easing-standard)}.hover{background-color:rgba(var(--mdui-comp-ripple-state-layer-color,var(--mdui-color-on-surface)),var(--mdui-state-layer-hover))}:host-context([focus-visible]) .focused{background-color:rgba(var(--mdui-comp-ripple-state-layer-color,var(--mdui-color-on-surface)),var(--mdui-state-layer-focus))}.dragged{background-color:rgba(var(--mdui-comp-ripple-state-layer-color,var(--mdui-color-on-surface)),var(--mdui-state-layer-dragged))}.wave{position:absolute;z-index:1;background-color:rgb(var(--mdui-comp-ripple-state-layer-color,var(--mdui-color-on-surface)));border-radius:50%;transform:translate3d(0,0,0) scale(.4);opacity:0;animation:225ms ease 0s 1 normal forwards running mdui-comp-ripple-radius-in,75ms ease 0s 1 normal forwards running mdui-comp-ripple-opacity-in;pointer-events:none}.out{transform:translate3d(var(--mdui-comp-ripple-transition-x,0),var(--mdui-comp-ripple-transition-y,0),0) scale(1);animation:150ms ease 0s 1 normal none running mdui-comp-ripple-opacity-out}@keyframes mdui-comp-ripple-radius-in{from{transform:translate3d(0,0,0) scale(.4);animation-timing-function:var(--mdui-motion-easing-standard)}to{transform:translate3d(var(--mdui-comp-ripple-transition-x,0),var(--mdui-comp-ripple-transition-y,0),0) scale(1)}}@keyframes mdui-comp-ripple-opacity-in{from{opacity:0;animation-timing-function:linear}to{opacity:var(--mdui-state-layer-pressed)}}@keyframes mdui-comp-ripple-opacity-out{from{animation-timing-function:linear;opacity:var(--mdui-state-layer-pressed)}to{opacity:0}}`;

// node_modules/mdui/components/ripple/index.js
var Ripple = class Ripple2 extends MduiElement {
  constructor() {
    super(...arguments);
    this.noRipple = false;
    this.hover = false;
    this.focused = false;
    this.dragged = false;
    this.surfaceRef = createRef();
  }
  startPress(event) {
    if (this.noRipple) {
      return;
    }
    const $surface = $(this.surfaceRef.value);
    const surfaceHeight = $surface.innerHeight();
    const surfaceWidth = $surface.innerWidth();
    let touchStartX;
    let touchStartY;
    if (!event) {
      touchStartX = surfaceWidth / 2;
      touchStartY = surfaceHeight / 2;
    } else {
      const touchPosition = typeof TouchEvent !== "undefined" && event instanceof TouchEvent && event.touches.length ? event.touches[0] : event;
      const offset = $surface.offset();
      if (touchPosition.pageX < offset.left || touchPosition.pageX > offset.left + surfaceWidth || touchPosition.pageY < offset.top || touchPosition.pageY > offset.top + surfaceHeight) {
        return;
      }
      touchStartX = touchPosition.pageX - offset.left;
      touchStartY = touchPosition.pageY - offset.top;
    }
    const diameter = Math.max(Math.pow(Math.pow(surfaceHeight, 2) + Math.pow(surfaceWidth, 2), 0.5), 48);
    const translateX = `${-touchStartX + surfaceWidth / 2}px`;
    const translateY = `${-touchStartY + surfaceHeight / 2}px`;
    const translate = `translate3d(${translateX}, ${translateY}, 0) scale(1)`;
    $('<div class="wave"></div>').css({
      width: diameter,
      height: diameter,
      marginTop: -diameter / 2,
      marginLeft: -diameter / 2,
      left: touchStartX,
      top: touchStartY
    }).each((_, wave) => {
      wave.style.setProperty("--mdui-comp-ripple-transition-x", translateX);
      wave.style.setProperty("--mdui-comp-ripple-transition-y", translateY);
    }).prependTo(this.surfaceRef.value).each((_, wave) => wave.clientLeft).css("transform", translate).on("animationend", function(e) {
      const event2 = e;
      if (event2.animationName === "mdui-comp-ripple-radius-in") {
        $(this).data("filled", true);
      }
    });
  }
  endPress() {
    const $waves = $(this.surfaceRef.value).children().filter((_, wave) => !$(wave).data("removing")).data("removing", true);
    const hideAndRemove = ($waves2) => {
      $waves2.addClass("out").each((_, wave) => wave.clientLeft).on("animationend", function() {
        $(this).remove();
      });
    };
    $waves.filter((_, wave) => !$(wave).data("filled")).on("animationend", function(e) {
      const event = e;
      if (event.animationName === "mdui-comp-ripple-radius-in") {
        hideAndRemove($(this));
      }
    });
    hideAndRemove($waves.filter((_, wave) => !!$(wave).data("filled")));
  }
  startHover() {
    this.hover = true;
  }
  endHover() {
    this.hover = false;
  }
  startFocus() {
    this.focused = true;
  }
  endFocus() {
    this.focused = false;
  }
  startDrag() {
    this.dragged = true;
  }
  endDrag() {
    this.dragged = false;
  }
  render() {
    return html`<div ${ref(this.surfaceRef)} class="surface ${classMap({
      hover: this.hover,
      focused: this.focused,
      dragged: this.dragged
    })}"></div>`;
  }
};
Ripple.styles = [componentStyle, style2];
__decorate([
  property({
    type: Boolean,
    reflect: true,
    converter: booleanConverter,
    attribute: "no-ripple"
  })
], Ripple.prototype, "noRipple", void 0);
__decorate([
  state()
], Ripple.prototype, "hover", void 0);
__decorate([
  state()
], Ripple.prototype, "focused", void 0);
__decorate([
  state()
], Ripple.prototype, "dragged", void 0);
Ripple = __decorate([
  customElement("mdui-ripple")
], Ripple);

// node_modules/classcat/index.js
function cc(names) {
  if (typeof names === "string" || typeof names === "number") return "" + names;
  let out = "";
  if (Array.isArray(names)) {
    for (let i = 0, tmp; i < names.length; i++) {
      if ((tmp = cc(names[i])) !== "") {
        out += (out && " ") + tmp;
      }
    }
  } else {
    for (let k in names) {
      if (names[k]) out += (out && " ") + k;
    }
  }
  return out;
}

// node_modules/@mdui/shared/helpers/template.js
var nothingTemplate = html`${nothing}`;

// node_modules/lit-html/development/directives/if-defined.js
var ifDefined = (value) => value ?? nothing;

// node_modules/@mdui/shared/mixins/anchor.js
var AnchorMixin = (superclass) => {
  class AnchorMixinClass extends superclass {
    renderAnchor({ id, className, part, content = html`<slot></slot>`, refDirective, tabIndex }) {
      return html`<a ${refDirective} id="${ifDefined(id)}" class="_a ${className ? className : ""}" part="${ifDefined(part)}" href="${ifDefined(this.href)}" download="${ifDefined(this.download)}" target="${ifDefined(this.target)}" rel="${ifDefined(this.rel)}" tabindex="${ifDefined(tabIndex)}">${content}</a>`;
    }
  }
  __decorate([
    property({ reflect: true })
  ], AnchorMixinClass.prototype, "href", void 0);
  __decorate([
    property({ reflect: true })
  ], AnchorMixinClass.prototype, "download", void 0);
  __decorate([
    property({ reflect: true })
  ], AnchorMixinClass.prototype, "target", void 0);
  __decorate([
    property({ reflect: true })
  ], AnchorMixinClass.prototype, "rel", void 0);
  return AnchorMixinClass;
};

// node_modules/@mdui/jq/methods/removeAttr.js
$.fn.removeAttr = function(attributeName) {
  const names = attributeName.split(" ").filter((name) => name);
  return this.each(function() {
    eachArray(names, (name) => {
      removeAttribute(this, name);
    });
  });
};

// node_modules/@mdui/shared/mixins/focusable.js
var isClick = true;
var document2 = getDocument();
document2.addEventListener("pointerdown", () => {
  isClick = true;
});
document2.addEventListener("keydown", () => {
  isClick = false;
});
var FocusableMixin = (superclass) => {
  class FocusableMixinClass extends superclass {
    constructor() {
      super(...arguments);
      this.autofocus = false;
      this.focused = false;
      this.focusVisible = false;
      this.focusableDefinedController = new DefinedController(this, { relatedElements: [""] });
      this._manipulatingTabindex = false;
      this._tabIndex = 0;
    }
    /**
     * 元素在使用 Tab 键切换焦点时的顺序
     */
    get tabIndex() {
      const $this = $(this);
      if (this.focusElement === this) {
        return Number($this.attr("tabindex") || -1);
      }
      const tabIndexAttribute = Number($this.attr("tabindex") || 0);
      if (this.focusDisabled || tabIndexAttribute < 0) {
        return -1;
      }
      if (!this.focusElement) {
        return tabIndexAttribute;
      }
      return this.focusElement.tabIndex;
    }
    set tabIndex(tabIndex) {
      if (this._manipulatingTabindex) {
        this._manipulatingTabindex = false;
        return;
      }
      const $this = $(this);
      if (this.focusElement === this) {
        if (tabIndex !== null) {
          this._tabIndex = tabIndex;
        }
        $this.attr("tabindex", this.focusDisabled ? null : tabIndex);
        return;
      }
      const onPointerDown = () => {
        if (this.tabIndex === -1) {
          this.tabIndex = 0;
          this.focus({ preventScroll: true });
        }
      };
      if (tabIndex === -1) {
        this.addEventListener("pointerdown", onPointerDown);
      } else {
        this._manipulatingTabindex = true;
        this.removeEventListener("pointerdown", onPointerDown);
      }
      if (tabIndex === -1 || this.focusDisabled) {
        $this.attr("tabindex", -1);
        if (tabIndex !== -1) {
          this.manageFocusElementTabindex(tabIndex);
        }
        return;
      }
      if (!this.hasAttribute("tabindex")) {
        this._manipulatingTabindex = false;
      }
      this.manageFocusElementTabindex(tabIndex);
    }
    /**
     * 父类要实现该属性，表示是否禁用 focus 状态
     */
    get focusDisabled() {
      throw new Error("Must implement focusDisabled getter!");
    }
    /**
     * 最终获得焦点的元素
     */
    get focusElement() {
      throw new Error("Must implement focusElement getter!");
    }
    connectedCallback() {
      super.connectedCallback();
      this.updateComplete.then(() => {
        requestAnimationFrame(() => {
          this.manageAutoFocus();
        });
      });
    }
    /**
     * 模拟鼠标点击元素
     */
    click() {
      if (this.focusDisabled) {
        return;
      }
      if (this.focusElement !== this) {
        this.focusElement.click();
      } else {
        HTMLElement.prototype.click.apply(this);
      }
    }
    /**
     * 将焦点设置到当前元素。
     *
     * 可以传入一个对象作为参数，该对象的属性包括：
     *
     * * `preventScroll`：默认情况下，元素获取焦点后，页面会滚动以将该元素滚动到视图中。如果不希望页面滚动，可以将此属性设置为 `true`。
     */
    focus(options) {
      if (this.focusDisabled || !this.focusElement) {
        return;
      }
      if (this.focusElement !== this) {
        this.focusElement.focus(options);
      } else {
        HTMLElement.prototype.focus.apply(this, [options]);
      }
    }
    /**
     * 移除当前元素的焦点
     */
    blur() {
      if (this.focusElement !== this) {
        this.focusElement.blur();
      } else {
        HTMLElement.prototype.blur.apply(this);
      }
    }
    firstUpdated(changedProperties) {
      super.firstUpdated(changedProperties);
      this.focusElement.addEventListener("focus", () => {
        this.focused = true;
        this.focusVisible = !isClick;
      });
      this.focusElement.addEventListener("blur", () => {
        this.focused = false;
        this.focusVisible = false;
      });
    }
    update(changedProperties) {
      if (this._lastFocusDisabled === void 0 || this._lastFocusDisabled !== this.focusDisabled) {
        this._lastFocusDisabled = this.focusDisabled;
        const $this = $(this);
        if (this.focusDisabled) {
          $this.removeAttr("tabindex");
        } else {
          if (this.focusElement === this) {
            this._manipulatingTabindex = true;
            $this.attr("tabindex", this._tabIndex);
          } else if (this.tabIndex > -1) {
            $this.removeAttr("tabindex");
          }
        }
      }
      super.update(changedProperties);
    }
    updated(changedProperties) {
      super.updated(changedProperties);
      if (this.focused && this.focusDisabled) {
        this.blur();
      }
    }
    async manageFocusElementTabindex(tabIndex) {
      if (!this.focusElement) {
        await this.updateComplete;
      }
      if (tabIndex === null) {
        this.focusElement.removeAttribute("tabindex");
      } else {
        this.focusElement.tabIndex = tabIndex;
      }
    }
    manageAutoFocus() {
      if (this.autofocus) {
        this.dispatchEvent(new KeyboardEvent("keydown", {
          code: "Tab"
        }));
        this.focusElement.focus();
      }
    }
  }
  __decorate([
    property({
      type: Boolean,
      /**
       * 哪些属性需要 reflect: true？
       * 一般所有属性都需要 reflect，但以下情况除外：
       * 1. 会频繁变更的属性
       * 2. 属性同步会造成较大性能开销的属性
       * 3. 复杂类型属性（数组、对象等，仅提供 property，不提供 attribute）
       */
      reflect: true,
      converter: booleanConverter
    })
  ], FocusableMixinClass.prototype, "autofocus", void 0);
  __decorate([
    property({
      type: Boolean,
      reflect: true,
      converter: booleanConverter
    })
  ], FocusableMixinClass.prototype, "focused", void 0);
  __decorate([
    property({
      type: Boolean,
      reflect: true,
      converter: booleanConverter,
      attribute: "focus-visible"
    })
  ], FocusableMixinClass.prototype, "focusVisible", void 0);
  __decorate([
    property({ type: Number, attribute: "tabindex" })
  ], FocusableMixinClass.prototype, "tabIndex", null);
  return FocusableMixinClass;
};

// node_modules/@mdui/jq/methods/utils/dir.js
var dir = ($elements, nameIndex, node, selector, filter) => {
  const ret = [];
  let target;
  $elements.each((_, element) => {
    target = element[node];
    while (target && isElement(target)) {
      if (nameIndex === 2) {
        if (selector && $(target).is(selector)) {
          break;
        }
        if (!filter || $(target).is(filter)) {
          ret.push(target);
        }
      } else if (nameIndex === 0) {
        if (!selector || $(target).is(selector)) {
          ret.push(target);
        }
        break;
      } else {
        if (!selector || $(target).is(selector)) {
          ret.push(target);
        }
      }
      target = target[node];
    }
  });
  return new JQ(unique(ret));
};

// node_modules/@mdui/jq/methods/parent.js
eachArray(["", "s", "sUntil"], (name, nameIndex) => {
  $.fn[`parent${name}`] = function(selector, filter) {
    const $nodes = !nameIndex ? this : $(this.get().reverse());
    return dir($nodes, nameIndex, "parentNode", selector, filter);
  };
});

// node_modules/@mdui/jq/methods/index.js
$.fn.index = function(selector) {
  if (!arguments.length) {
    return this.eq(0).parent().children().get().indexOf(this[0]);
  }
  if (isString(selector)) {
    return $(selector).get().indexOf(this[0]);
  }
  return this.get().indexOf($(selector)[0]);
};

// node_modules/mdui/components/ripple/ripple-mixin.js
var RippleMixin = (superclass) => {
  class Mixin extends superclass {
    constructor() {
      super(...arguments);
      this.noRipple = false;
      this.rippleIndex = void 0;
      this.getRippleIndex = () => this.rippleIndex;
    }
    /**
     * 子类要添加该属性，指向 <mdui-ripple> 元素
     * 如果一个组件中包含多个 <mdui-ripple> 元素，则这里可以是一个数组或 NodeList
     */
    get rippleElement() {
      throw new Error("Must implement rippleElement getter!");
    }
    /**
     * 子类要实现该属性，表示是否禁用 ripple
     * 如果一个组件中包含多个 <mdui-ripple> 元素，则这里可以是一个数组；也可以是单个值，同时控制多个 <mdui-ripple> 元素
     */
    get rippleDisabled() {
      throw new Error("Must implement rippleDisabled getter!");
    }
    /**
     * 当前 <mdui-ripple> 元素相对于哪个元素存在，即 hover、pressed、dragged 属性要添加到哪个元素上，默认为 :host
     * 如果需要修改该属性，则子类可以实现该属性
     * 如果一个组件中包含多个 <mdui-ripple> 元素，则这里可以是一个数组；也可以是单个值，同时控制多个 <mdui-ripple> 元素
     */
    get rippleTarget() {
      return this;
    }
    firstUpdated(changedProperties) {
      super.firstUpdated(changedProperties);
      const $rippleTarget = $(this.rippleTarget);
      const setRippleIndex = (event) => {
        if (isArrayLike(this.rippleTarget)) {
          this.rippleIndex = $rippleTarget.index(event.target);
        }
      };
      const rippleTargetArr = isArrayLike(this.rippleTarget) ? this.rippleTarget : [this.rippleTarget];
      rippleTargetArr.forEach((rippleTarget) => {
        rippleTarget.addEventListener("pointerdown", (event) => {
          setRippleIndex(event);
          this.startPress(event);
        });
        rippleTarget.addEventListener("pointerenter", (event) => {
          setRippleIndex(event);
          this.startHover(event);
        });
        rippleTarget.addEventListener("pointerleave", (event) => {
          setRippleIndex(event);
          this.endHover(event);
        });
        rippleTarget.addEventListener("focus", (event) => {
          setRippleIndex(event);
          this.startFocus();
        });
        rippleTarget.addEventListener("blur", (event) => {
          setRippleIndex(event);
          this.endFocus();
        });
      });
    }
    /**
     * 若存在多个 <mdui-ripple>，但 rippleTarget 为同一个，则 hover 状态无法在多个 <mdui-ripple> 之间切换
     * 所以把 startHover 和 endHover 设置为 protected，供子类调用
     * 子类中，在 getRippleIndex() 的返回值变更前调用 endHover(event)，变更后调用 startHover(event)
     */
    startHover(event) {
      if (event.pointerType !== "mouse" || this.isRippleDisabled()) {
        return;
      }
      this.getRippleTarget().setAttribute("hover", "");
      this.getRippleElement().startHover();
    }
    endHover(event) {
      if (event.pointerType !== "mouse" || this.isRippleDisabled()) {
        return;
      }
      this.getRippleTarget().removeAttribute("hover");
      this.getRippleElement().endHover();
    }
    /**
     * 当前激活的 <mdui-ripple> 元素是否被禁用
     */
    isRippleDisabled() {
      const disabled = this.rippleDisabled;
      if (!Array.isArray(disabled)) {
        return disabled;
      }
      const rippleIndex = this.getRippleIndex();
      if (rippleIndex !== void 0) {
        return disabled[rippleIndex];
      }
      return disabled.length ? disabled[0] : false;
    }
    /**
     * 获取当前激活的 <mdui-ripple> 元素实例
     */
    getRippleElement() {
      const ripple = this.rippleElement;
      if (!isArrayLike(ripple)) {
        return ripple;
      }
      const rippleIndex = this.getRippleIndex();
      if (rippleIndex !== void 0) {
        return ripple[rippleIndex];
      }
      return ripple[0];
    }
    /**
     * 获取当前激活的 <mdui-ripple> 元素相对于哪个元素存在
     */
    getRippleTarget() {
      const target = this.rippleTarget;
      if (!isArrayLike(target)) {
        return target;
      }
      const rippleIndex = this.getRippleIndex();
      if (rippleIndex !== void 0) {
        return target[rippleIndex];
      }
      return target[0];
    }
    startFocus() {
      if (this.isRippleDisabled()) {
        return;
      }
      this.getRippleElement().startFocus();
    }
    endFocus() {
      if (this.isRippleDisabled()) {
        return;
      }
      this.getRippleElement().endFocus();
    }
    startPress(event) {
      if (this.isRippleDisabled() || event.button) {
        return;
      }
      const target = this.getRippleTarget();
      target.setAttribute("pressed", "");
      if (["touch", "pen"].includes(event.pointerType)) {
        let hidden = false;
        let timer = setTimeout(() => {
          timer = 0;
          this.getRippleElement().startPress(event);
        }, 70);
        const hideRipple = () => {
          if (timer) {
            clearTimeout(timer);
            timer = 0;
            this.getRippleElement().startPress(event);
          }
          if (!hidden) {
            hidden = true;
            this.endPress();
          }
          target.removeEventListener("pointerup", hideRipple);
          target.removeEventListener("pointercancel", hideRipple);
        };
        const touchMove = () => {
          if (timer) {
            clearTimeout(timer);
            timer = 0;
          }
          target.removeEventListener("touchmove", touchMove);
        };
        target.addEventListener("touchmove", touchMove);
        target.addEventListener("pointerup", hideRipple);
        target.addEventListener("pointercancel", hideRipple);
      }
      if (event.pointerType === "mouse" && event.button === 0) {
        const hideRipple = () => {
          this.endPress();
          target.removeEventListener("pointerup", hideRipple);
          target.removeEventListener("pointercancel", hideRipple);
          target.removeEventListener("pointerleave", hideRipple);
        };
        this.getRippleElement().startPress(event);
        target.addEventListener("pointerup", hideRipple);
        target.addEventListener("pointercancel", hideRipple);
        target.addEventListener("pointerleave", hideRipple);
      }
    }
    endPress() {
      if (this.isRippleDisabled()) {
        return;
      }
      this.getRippleTarget().removeAttribute("pressed");
      this.getRippleElement().endPress();
    }
    startDrag() {
      if (this.isRippleDisabled()) {
        return;
      }
      this.getRippleElement().startDrag();
    }
    endDrag() {
      if (this.isRippleDisabled()) {
        return;
      }
      this.getRippleElement().endDrag();
    }
  }
  __decorate([
    property({
      type: Boolean,
      reflect: true,
      converter: booleanConverter,
      attribute: "no-ripple"
    })
  ], Mixin.prototype, "noRipple", void 0);
  return Mixin;
};

export {
  classMap,
  isSingleExpression,
  setCommittedValue,
  createRef,
  ref,
  cc,
  nothingTemplate,
  ifDefined,
  AnchorMixin,
  FocusableMixin,
  styleMap,
  contains,
  merge,
  extend,
  globalOptions,
  param,
  ajax,
  Icon,
  dir,
  getAll,
  get,
  setAll,
  set,
  removeAll,
  removeMultiple,
  each,
  map,
  Ripple,
  RippleMixin
};
/*! Bundled license information:

lit-html/development/directives/style-map.js:
lit-html/development/directives/class-map.js:
lit-html/development/directives/if-defined.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/development/directive-helpers.js:
lit-html/development/directives/ref.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/development/async-directive.js:
lit-html/development/directives/until.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/development/directives/private-async-helpers.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=chunk-VLYWBSIC.js.map
