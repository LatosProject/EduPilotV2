import {
  observeResize,
  watch,
  when
} from "./chunk-7QV74WTN.js";
import {
  ButtonBase
} from "./chunk-FITIL2ER.js";
import {
  createRef,
  nothingTemplate,
  ref
} from "./chunk-VLYWBSIC.js";
import {
  $,
  HasSlotController,
  MduiElement,
  booleanConverter,
  componentStyle,
  getDocument,
  getWindow,
  isElement,
  isNumber,
  isUndefined,
  property,
  returnTrue,
  toKebabCase
} from "./chunk-TEJKIG4D.js";
import {
  style,
  svgTag
} from "./chunk-4P5N65FR.js";
import {
  LitElement,
  __decorate,
  css,
  customElement,
  html
} from "./chunk-TAWH3UXR.js";

// node_modules/is-promise/index.mjs
function isPromise(obj) {
  return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
}

// node_modules/@mdui/shared/helpers/queue.js
var container = {};
function queue(name, func) {
  if (isUndefined(container[name])) {
    container[name] = [];
  }
  if (isUndefined(func)) {
    return container[name];
  }
  container[name].push(func);
}
function dequeue(name) {
  if (isUndefined(container[name])) {
    return;
  }
  if (!container[name].length) {
    return;
  }
  const func = container[name].shift();
  func();
}

// node_modules/@mdui/shared/helpers/animate.js
function animateTo(el, keyframes, options) {
  if (!el) {
    return Promise.resolve();
  }
  return new Promise((resolve) => {
    if (options.duration === Infinity) {
      throw new Error("Promise-based animations must be finite.");
    }
    if (isNumber(options.duration) && isNaN(options.duration)) {
      options.duration = 0;
    }
    if (options.easing === "") {
      options.easing = "linear";
    }
    const animation = el.animate(keyframes, options);
    animation.addEventListener("cancel", resolve, { once: true });
    animation.addEventListener("finish", resolve, { once: true });
  });
}
function stopAnimations(el) {
  if (!el) {
    return Promise.resolve();
  }
  return Promise.all(el.getAnimations().map((animation) => {
    return new Promise((resolve) => {
      const handleAnimationEvent = requestAnimationFrame(resolve);
      animation.addEventListener("cancel", () => handleAnimationEvent, {
        once: true
      });
      animation.addEventListener("finish", () => handleAnimationEvent, {
        once: true
      });
      animation.cancel();
    });
  }));
}

// node_modules/@mdui/shared/helpers/breakpoint.js
var breakpoint = (width) => {
  const window2 = getWindow();
  const document2 = getDocument();
  const computedStyle = window2.getComputedStyle(document2.documentElement);
  const containerWidth = isElement(width) ? $(width).innerWidth() : isNumber(width) ? width : $(window2).innerWidth();
  const getBreakpointValue = (breakpoint2) => {
    const width2 = computedStyle.getPropertyValue(`--mdui-breakpoint-${breakpoint2}`).toLowerCase();
    return parseFloat(width2);
  };
  const getNextBreakpoint = (breakpoint2) => {
    switch (breakpoint2) {
      case "xs":
        return "sm";
      case "sm":
        return "md";
      case "md":
        return "lg";
      case "lg":
        return "xl";
      case "xl":
        return "xxl";
    }
  };
  return {
    /**
     * 当前宽度是否大于指定断点值
     * @param breakpoint
     */
    up(breakpoint2) {
      return containerWidth >= getBreakpointValue(breakpoint2);
    },
    /**
     * 当前宽度是否小于指定断点值
     * @param breakpoint
     */
    down(breakpoint2) {
      return containerWidth < getBreakpointValue(breakpoint2);
    },
    /**
     * 当前宽度是否在指定断点值内
     * @param breakpoint
     */
    only(breakpoint2) {
      if (breakpoint2 === "xxl") {
        return this.up(breakpoint2);
      } else {
        return this.up(breakpoint2) && this.down(getNextBreakpoint(breakpoint2));
      }
    },
    /**
     * 当前宽度是否不在指定断点值内
     * @param breakpoint
     */
    not(breakpoint2) {
      return !this.only(breakpoint2);
    },
    /**
     * 当前宽度是否在指定断点值之间
     * @param startBreakpoint
     * @param endBreakpoint
     * @returns
     */
    between(startBreakpoint, endBreakpoint) {
      return this.up(startBreakpoint) && this.down(endBreakpoint);
    }
  };
};

// node_modules/@mdui/shared/helpers/motion.js
var getEasing = (element, name) => {
  const cssVariableName = `--mdui-motion-easing-${name}`;
  return $(element).css(cssVariableName).trim();
};
var getDuration = (element, name) => {
  const cssVariableName = `--mdui-motion-duration-${name}`;
  const cssValue = $(element).css(cssVariableName).trim().toLowerCase();
  if (cssValue.endsWith("ms")) {
    return parseFloat(cssValue);
  } else {
    return parseFloat(cssValue) * 1e3;
  }
};

// node_modules/@mdui/shared/icons/clear.js
var IconClear = class IconClear2 extends LitElement {
  render() {
    return svgTag('<path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>');
  }
};
IconClear.styles = style;
IconClear = __decorate([
  customElement("mdui-icon-clear")
], IconClear);

// node_modules/mdui/components/button-icon/style.js
var style2 = css`:host{--shape-corner:var(--mdui-shape-corner-full);position:relative;display:inline-block;flex-shrink:0;overflow:hidden;text-align:center;border-radius:var(--shape-corner);cursor:pointer;-webkit-tap-highlight-color:transparent;font-size:1.5rem;width:2.5rem;height:2.5rem}:host([variant=standard]){color:rgb(var(--mdui-color-on-surface-variant));--mdui-comp-ripple-state-layer-color:var(--mdui-color-on-surface-variant)}:host([variant=filled]){color:rgb(var(--mdui-color-primary));background-color:rgb(var(--mdui-color-surface-container-highest));--mdui-comp-ripple-state-layer-color:var(--mdui-color-primary)}:host([variant=tonal]){color:rgb(var(--mdui-color-on-surface-variant));background-color:rgb(var(--mdui-color-surface-container-highest));--mdui-comp-ripple-state-layer-color:var(--mdui-color-on-surface-variant)}:host([variant=outlined]){border:.0625rem solid rgb(var(--mdui-color-outline));color:rgb(var(--mdui-color-on-surface-variant));--mdui-comp-ripple-state-layer-color:var(--mdui-color-on-surface-variant)}:host([variant=outlined][pressed]){color:rgb(var(--mdui-color-on-surface));--mdui-comp-ripple-state-layer-color:var(--mdui-color-on-surface)}:host([variant=standard][selected]:not([selected=false i])){color:rgb(var(--mdui-color-primary));--mdui-comp-ripple-state-layer-color:var(--mdui-color-primary)}:host([variant=filled]:not([selectable])),:host([variant=filled][selectable=false i]),:host([variant=filled][selected]:not([selected=false i])){color:rgb(var(--mdui-color-on-primary));background-color:rgb(var(--mdui-color-primary));--mdui-comp-ripple-state-layer-color:var(--mdui-color-on-primary)}:host([variant=tonal]:not([selectable])),:host([variant=tonal][selectable=false i]),:host([variant=tonal][selected]:not([selected=false i])){color:rgb(var(--mdui-color-on-secondary-container));background-color:rgb(var(--mdui-color-secondary-container));--mdui-comp-ripple-state-layer-color:var(
      --mdui-color-on-secondary-container
    )}:host([variant=outlined][selected]:not([selected=false i])){border:none;color:rgb(var(--mdui-color-inverse-on-surface));background-color:rgb(var(--mdui-color-inverse-surface));--mdui-comp-ripple-state-layer-color:var(--mdui-color-inverse-on-surface)}:host([variant=filled][disabled]:not([disabled=false i])),:host([variant=outlined][disabled]:not([disabled=false i])),:host([variant=tonal][disabled]:not([disabled=false i])){background-color:rgba(var(--mdui-color-on-surface),.12);border-color:rgba(var(--mdui-color-on-surface),.12)}:host([disabled]:not([disabled=false i])),:host([loading]:not([loading=false i])){cursor:default;pointer-events:none}:host([disabled]:not([disabled=false i])){color:rgba(var(--mdui-color-on-surface),.38)!important}.button{float:left;width:100%}:host([loading]:not([loading=false i])) .button,:host([loading]:not([loading=false i])) mdui-ripple{opacity:0}.icon,.selected-icon mdui-icon,::slotted(*){font-size:inherit}mdui-circular-progress{display:flex;position:absolute;top:calc(50% - 1.5rem / 2);left:calc(50% - 1.5rem / 2);width:1.5rem;height:1.5rem}:host([variant=filled]:not([disabled])) mdui-circular-progress,:host([variant=filled][disabled=false i]) mdui-circular-progress{stroke:rgb(var(--mdui-color-on-primary))}:host([disabled]:not([disabled=false i])) mdui-circular-progress{stroke:rgba(var(--mdui-color-on-surface),38%)}`;

// node_modules/mdui/components/button-icon/index.js
var ButtonIcon = class ButtonIcon2 extends ButtonBase {
  constructor() {
    super(...arguments);
    this.variant = "standard";
    this.selectable = false;
    this.selected = false;
    this.rippleRef = createRef();
    this.hasSlotController = new HasSlotController(this, "[default]", "selected-icon");
  }
  get rippleElement() {
    return this.rippleRef.value;
  }
  onSelectedChange() {
    this.emit("change");
  }
  firstUpdated(changedProperties) {
    super.firstUpdated(changedProperties);
    this.addEventListener("click", () => {
      if (!this.selectable || this.disabled) {
        return;
      }
      this.selected = !this.selected;
    });
  }
  render() {
    return html`<mdui-ripple ${ref(this.rippleRef)} .noRipple="${this.noRipple}"></mdui-ripple>${this.isButton() ? this.renderButton({
      className: "button",
      part: "button",
      content: this.renderIcon()
    }) : this.disabled || this.loading ? html`<span part="button" class="button _a">${this.renderIcon()}</span>` : this.renderAnchor({
      className: "button",
      part: "button",
      content: this.renderIcon()
    })} ${this.renderLoading()}`;
  }
  renderIcon() {
    const icon = () => this.hasSlotController.test("[default]") ? html`<slot></slot>` : this.icon ? html`<mdui-icon part="icon" class="icon" name="${this.icon}"></mdui-icon>` : nothingTemplate;
    const selectedIcon = () => this.hasSlotController.test("selected-icon") || this.selectedIcon ? html`<slot name="selected-icon" part="selected-icon" class="selected-icon"><mdui-icon name="${this.selectedIcon}"></mdui-icon></slot>` : icon();
    return this.selected ? selectedIcon() : icon();
  }
};
ButtonIcon.styles = [ButtonBase.styles, style2];
__decorate([
  property({ reflect: true })
], ButtonIcon.prototype, "variant", void 0);
__decorate([
  property({ reflect: true })
], ButtonIcon.prototype, "icon", void 0);
__decorate([
  property({ reflect: true, attribute: "selected-icon" })
], ButtonIcon.prototype, "selectedIcon", void 0);
__decorate([
  property({
    type: Boolean,
    reflect: true,
    converter: booleanConverter
  })
], ButtonIcon.prototype, "selectable", void 0);
__decorate([
  property({
    type: Boolean,
    reflect: true,
    converter: booleanConverter
  })
], ButtonIcon.prototype, "selected", void 0);
__decorate([
  watch("selected", true)
], ButtonIcon.prototype, "onSelectedChange", null);
ButtonIcon = __decorate([
  customElement("mdui-button-icon")
], ButtonIcon);

// node_modules/mdui/components/snackbar/style.js
var style3 = css`:host{--shape-corner:var(--mdui-shape-corner-extra-small);--z-index:2400;position:fixed;z-index:var(--z-index);display:none;align-items:center;flex-wrap:wrap;border-radius:var(--shape-corner);transform:scaleY(0);transition:transform 0s var(--mdui-motion-easing-linear) var(--mdui-motion-duration-short4);min-width:20rem;max-width:36rem;padding:.25rem 0;box-shadow:var(--mdui-elevation-level3);background-color:rgb(var(--mdui-color-inverse-surface));color:rgb(var(--mdui-color-inverse-on-surface));font-size:var(--mdui-typescale-body-medium-size);font-weight:var(--mdui-typescale-body-medium-weight);letter-spacing:var(--mdui-typescale-body-medium-tracking);line-height:var(--mdui-typescale-body-medium-line-height)}:host([placement^=top]){transform-origin:top}:host([placement^=bottom]){transform-origin:bottom}:host([placement=bottom-start]:not([mobile])),:host([placement=top-start]:not([mobile])){left:1rem}:host([placement=bottom-end]:not([mobile])),:host([placement=top-end]:not([mobile])){right:1rem}:host([placement=bottom]:not([mobile])),:host([placement=top]:not([mobile])){left:50%;transform:scaleY(0) translateX(-50%)}:host([mobile]){min-width:0;left:1rem;right:1rem}:host([open]){transform:scaleY(1);transition:top var(--mdui-motion-duration-short4) var(--mdui-motion-easing-standard),bottom var(--mdui-motion-duration-short4) var(--mdui-motion-easing-standard),transform var(--mdui-motion-duration-medium4) var(--mdui-motion-easing-emphasized-decelerate)}:host([placement=bottom][open]:not([mobile])),:host([placement=top][open]:not([mobile])){transform:scaleY(1) translateX(-50%)}.message{display:block;margin:.625rem 1rem}:host([message-line='1']) .message{overflow:hidden;white-space:nowrap;text-overflow:ellipsis}:host([message-line='2']) .message{display:-webkit-box;overflow:hidden;text-overflow:ellipsis;-webkit-box-orient:vertical;-webkit-line-clamp:2}.action-group{display:flex;align-items:center;margin-left:auto;padding-right:.5rem}.action,.close-button{display:inline-flex;align-items:center;justify-content:center}.action{color:rgb(var(--mdui-color-inverse-primary));font-size:var(--mdui-typescale-label-large-size);font-weight:var(--mdui-typescale-label-large-weight);letter-spacing:var(--mdui-typescale-label-large-tracking)}.action mdui-button,::slotted(mdui-button[slot=action][variant=outlined]),::slotted(mdui-button[slot=action][variant=text]){color:inherit;font-size:inherit;font-weight:inherit;letter-spacing:inherit;--mdui-comp-ripple-state-layer-color:var(--mdui-color-inverse-primary)}.action mdui-button::part(button){padding:0 .5rem}.close-button{margin:0 -.25rem 0 .25rem;font-size:1.5rem;color:rgb(var(--mdui-color-inverse-on-surface))}.close-button mdui-button-icon,::slotted(mdui-button-icon[slot=close-button][variant=outlined]),::slotted(mdui-button-icon[slot=close-button][variant=standard]){font-size:inherit;color:inherit;--mdui-comp-ripple-state-layer-color:var(--mdui-color-inverse-on-surface)}.close-button .i,::slotted([slot=close-icon]){font-size:inherit}`;

// node_modules/mdui/components/snackbar/index.js
var stacks = [];
var reordering = false;
var Snackbar = class Snackbar2 extends MduiElement {
  constructor() {
    super();
    this.open = false;
    this.placement = "bottom";
    this.actionLoading = false;
    this.closeable = false;
    this.autoCloseDelay = 5e3;
    this.closeOnOutsideClick = false;
    this.mobile = false;
    this.onDocumentClick = this.onDocumentClick.bind(this);
  }
  async onOpenChange() {
    const easingLinear = getEasing(this, "linear");
    const children = Array.from(this.renderRoot.querySelectorAll(".message, .action-group"));
    if (this.open) {
      const hasUpdated = this.hasUpdated;
      if (!hasUpdated) {
        await this.updateComplete;
      }
      if (hasUpdated) {
        const eventProceeded = this.emit("open", { cancelable: true });
        if (!eventProceeded) {
          return;
        }
      }
      window.clearTimeout(this.closeTimeout);
      if (this.autoCloseDelay) {
        this.closeTimeout = window.setTimeout(() => {
          this.open = false;
        }, this.autoCloseDelay);
      }
      this.style.display = "flex";
      await Promise.all([
        stopAnimations(this),
        ...children.map((child) => stopAnimations(child))
      ]);
      stacks.push({
        height: this.clientHeight,
        snackbar: this
      });
      await this.reorderStack(this);
      const duration = getDuration(this, "medium4");
      await Promise.all([
        animateTo(this, [{ opacity: 0 }, { opacity: 1, offset: 0.5 }, { opacity: 1 }], {
          duration: hasUpdated ? duration : 0,
          easing: easingLinear,
          fill: "forwards"
        }),
        ...children.map((child) => animateTo(child, [
          { opacity: 0 },
          { opacity: 0, offset: 0.2 },
          { opacity: 1, offset: 0.8 },
          { opacity: 1 }
        ], {
          duration: hasUpdated ? duration : 0,
          easing: easingLinear
        }))
      ]);
      if (hasUpdated) {
        this.emit("opened");
      }
      return;
    }
    if (!this.open && this.hasUpdated) {
      const eventProceeded = this.emit("close", { cancelable: true });
      if (!eventProceeded) {
        return;
      }
      window.clearTimeout(this.closeTimeout);
      await Promise.all([
        stopAnimations(this),
        ...children.map((child) => stopAnimations(child))
      ]);
      const duration = getDuration(this, "short4");
      await Promise.all([
        animateTo(this, [{ opacity: 1 }, { opacity: 0 }], {
          duration,
          easing: easingLinear,
          fill: "forwards"
        }),
        ...children.map((child) => animateTo(child, [{ opacity: 1 }, { opacity: 0, offset: 0.75 }, { opacity: 0 }], {
          duration,
          easing: easingLinear
        }))
      ]);
      this.style.display = "none";
      this.emit("closed");
      const stackIndex = stacks.findIndex((stack) => stack.snackbar === this);
      stacks.splice(stackIndex, 1);
      if (stacks[stackIndex]) {
        await this.reorderStack(stacks[stackIndex].snackbar);
      }
      return;
    }
  }
  /**
   * 这两个属性变更时，需要重新排序该组件后面的 snackbar
   */
  async onStackChange() {
    await this.reorderStack(this);
  }
  connectedCallback() {
    super.connectedCallback();
    document.addEventListener("pointerdown", this.onDocumentClick);
    this.mobile = breakpoint().down("sm");
    this.observeResize = observeResize(document.documentElement, async () => {
      const mobile = breakpoint().down("sm");
      if (this.mobile !== mobile) {
        this.mobile = mobile;
        if (!reordering) {
          reordering = true;
          await this.reorderStack();
          reordering = false;
        }
      }
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    document.removeEventListener("pointerdown", this.onDocumentClick);
    window.clearTimeout(this.closeTimeout);
    if (this.open) {
      this.open = false;
    }
    this.observeResize?.unobserve();
  }
  render() {
    return html`<slot part="message" class="message"></slot><div class="action-group"><slot name="action" part="action" class="action" @click="${this.onActionClick}">${this.action ? html`<mdui-button variant="text" loading="${this.actionLoading}">${this.action}</mdui-button>` : nothingTemplate}</slot>${when(this.closeable, () => html`<slot name="close-button" part="close-button" class="close-button" @click="${this.onCloseClick}"><mdui-button-icon><slot name="close-icon" part="close-icon">${this.closeIcon ? html`<mdui-icon name="${this.closeIcon}" class="i"></mdui-icon>` : html`<mdui-icon-clear class="i"></mdui-icon-clear>`}</slot></mdui-button-icon></slot>`)}</div>`;
  }
  /**
   * 重新排序 snackbar 堆叠
   * @param startSnackbar 从哪个 snackbar 开始重新排列，默认从第一个开始
   * @private
   */
  async reorderStack(startSnackbar) {
    const stackIndex = startSnackbar ? stacks.findIndex((stack) => stack.snackbar === startSnackbar) : 0;
    for (let i = stackIndex; i < stacks.length; i++) {
      const stack = stacks[i];
      const snackbar2 = stack.snackbar;
      if (this.mobile) {
        ["top", "bottom"].forEach((placement) => {
          if (snackbar2.placement.startsWith(placement)) {
            const prevStacks = stacks.filter((stack2, index) => {
              return index < i && stack2.snackbar.placement.startsWith(placement);
            });
            const prevHeight = prevStacks.reduce((prev, current) => prev + current.height, 0);
            snackbar2.style[placement] = `calc(${prevHeight}px + ${prevStacks.length + 1}rem)`;
            snackbar2.style[placement === "top" ? "bottom" : "top"] = "auto";
          }
        });
      } else {
        [
          "top",
          "top-start",
          "top-end",
          "bottom",
          "bottom-start",
          "bottom-end"
        ].forEach((placement) => {
          if (snackbar2.placement === placement) {
            const prevStacks = stacks.filter((stack2, index) => {
              return index < i && stack2.snackbar.placement === placement;
            });
            const prevHeight = prevStacks.reduce((prev, current) => prev + current.height, 0);
            snackbar2.style[placement.startsWith("top") ? "top" : "bottom"] = `calc(${prevHeight}px + ${prevStacks.length + 1}rem)`;
            snackbar2.style[placement.startsWith("top") ? "bottom" : "top"] = "auto";
          }
        });
      }
    }
  }
  /**
   * 在 document 上点击时，根据条件判断是否要关闭 snackbar
   */
  onDocumentClick(e) {
    if (!this.open || !this.closeOnOutsideClick) {
      return;
    }
    const target = e.target;
    if (!this.contains(target) && this !== target) {
      this.open = false;
    }
  }
  onActionClick(event) {
    event.stopPropagation();
    this.emit("action-click");
  }
  onCloseClick() {
    this.open = false;
  }
};
Snackbar.styles = [componentStyle, style3];
__decorate([
  property({
    type: Boolean,
    reflect: true,
    converter: booleanConverter
  })
], Snackbar.prototype, "open", void 0);
__decorate([
  property({ reflect: true })
], Snackbar.prototype, "placement", void 0);
__decorate([
  property({ reflect: true, attribute: "action" })
], Snackbar.prototype, "action", void 0);
__decorate([
  property({
    type: Boolean,
    reflect: true,
    converter: booleanConverter,
    attribute: "action-loading"
  })
], Snackbar.prototype, "actionLoading", void 0);
__decorate([
  property({
    type: Boolean,
    reflect: true,
    converter: booleanConverter
  })
], Snackbar.prototype, "closeable", void 0);
__decorate([
  property({ reflect: true, attribute: "close-icon" })
], Snackbar.prototype, "closeIcon", void 0);
__decorate([
  property({ type: Number, reflect: true, attribute: "message-line" })
  // eslint-disable-next-line prettier/prettier
], Snackbar.prototype, "messageLine", void 0);
__decorate([
  property({ type: Number, reflect: true, attribute: "auto-close-delay" })
], Snackbar.prototype, "autoCloseDelay", void 0);
__decorate([
  property({
    type: Boolean,
    reflect: true,
    attribute: "close-on-outside-click",
    converter: booleanConverter
  })
], Snackbar.prototype, "closeOnOutsideClick", void 0);
__decorate([
  property({
    type: Boolean,
    reflect: true,
    converter: booleanConverter
  })
], Snackbar.prototype, "mobile", void 0);
__decorate([
  watch("open")
], Snackbar.prototype, "onOpenChange", null);
__decorate([
  watch("placement", true),
  watch("messageLine", true)
], Snackbar.prototype, "onStackChange", null);
Snackbar = __decorate([
  customElement("mdui-snackbar")
], Snackbar);

// node_modules/mdui/functions/snackbar.js
var queueName = "mdui.functions.snackbar.";
var currentSnackbar = void 0;
var snackbar = (options) => {
  const snackbar2 = new Snackbar();
  const $snackbar = $(snackbar2);
  Object.entries(options).forEach(([key, value]) => {
    if (key === "message") {
      snackbar2.innerHTML = value;
    } else if ([
      "onClick",
      "onActionClick",
      "onOpen",
      "onOpened",
      "onClose",
      "onClosed"
    ].includes(key)) {
      const eventName = toKebabCase(key.slice(2));
      $snackbar.on(eventName, (e) => {
        if (e.target !== snackbar2) {
          return;
        }
        if (key === "onActionClick") {
          const actionClick = (options.onActionClick ?? returnTrue).call(snackbar2, snackbar2);
          if (isPromise(actionClick)) {
            snackbar2.actionLoading = true;
            actionClick.then(() => {
              snackbar2.open = false;
            }).finally(() => {
              snackbar2.actionLoading = false;
            });
          } else if (actionClick !== false) {
            snackbar2.open = false;
          }
        } else {
          value.call(snackbar2, snackbar2);
        }
      });
    } else {
      snackbar2[key] = value;
    }
  });
  $snackbar.appendTo("body").on("closed", (e) => {
    if (e.target !== snackbar2) {
      return;
    }
    $snackbar.remove();
    if (options.queue) {
      currentSnackbar = void 0;
      dequeue(queueName + options.queue);
    }
  });
  if (!options.queue) {
    setTimeout(() => {
      snackbar2.open = true;
    });
  } else if (currentSnackbar) {
    queue(queueName + options.queue, () => {
      snackbar2.open = true;
      currentSnackbar = snackbar2;
    });
  } else {
    setTimeout(() => {
      snackbar2.open = true;
    });
    currentSnackbar = snackbar2;
  }
  return snackbar2;
};

export {
  ButtonIcon,
  animateTo,
  stopAnimations,
  getEasing,
  getDuration,
  breakpoint,
  Snackbar,
  isPromise,
  queue,
  dequeue,
  snackbar
};
//# sourceMappingURL=chunk-XXPROZVH.js.map
